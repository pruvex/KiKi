[
  {
    "full_code_block": "import { test, expect, _electron, type ElectronApplication, type Page } from '@playwright/test';\nimport path from 'path';\nimport nock from 'nock';\n\n// F√ºhrt alle Tests in dieser Datei nacheinander aus, um eine saubere Testumgebung zu gew√§hrleisten.\ntest.describe.configure({ mode: 'serial' });\n\n/**\n * @file Test-Suite f√ºr das Modul chat.api-connector\n * \n * Diese Tests validieren das Verhalten des API-Connectors im Electron-Main-Prozess.\n * Da wir den Main-Prozess nicht direkt testen k√∂nnen, nutzen wir den Renderer (gesteuert von Playwright)\n * als Br√ºcke, um √ºber IPC-Nachrichten mit dem Connector zu kommunizieren.\n * \n * Externe API-Aufrufe (z.B. an OpenAI) werden mit `nock` gemockt, um die Tests schnell,\n * zuverl√§ssig und unabh√§ngig von externen Diensten zu machen.\n */\ntest.describe('chat.api-connector: IPC and Logic Tests', () => {\n  let electronApp: ElectronApplication;\n  let mainWindow: Page;\n\n  const OPENAI_API_HOST = 'https://api.openai.com';\n\n  // Diese Funktion wird VOR JEDEM Test ausgef√ºhrt.\n  test.beforeEach(async () => {\n    // Starte die Electron-App\n    electronApp = await _electron.launch({ args: ['.'] });\n\n    // Finde das Hauptfenster und ignoriere das DevTools-Fenster.\n    await expect.poll(async () => {\n        return electronApp.windows().find(w => !w.url().startsWith('devtools://'));\n    }, {\n        message: 'Das Hauptfenster der Anwendung ist nicht rechtzeitig erschienen.',\n        timeout: 15000\n    }).toBeDefined();\n    mainWindow = electronApp.windows().find(w => !w.url().startsWith('devtools://'))!;\n\n    // Lausche auf unerwartete Fehler im Renderer-Prozess\n    mainWindow.on('pageerror', (error) => {\n      console.error('üí• Uncaught exception in renderer process:', error);\n    });\n  });\n\n  // Diese Funktion wird NACH JEDEM Test ausgef√ºhrt.\n  test.afterEach(async () => {\n    // Schlie√üe die App\n    if (electronApp) {\n      await electronApp.close();\n    }\n    // Bereinige alle Mocks, um sicherzustellen, dass sie nicht in andere Tests leaken.\n    nock.cleanAll();\n  });\n\n  /**\n   * Eine Hilfsfunktion, um die IPC-Kommunikation zu vereinfachen.\n   * Sie sendet eine Nachricht an den Main-Prozess und gibt die Antwort zur√ºck.\n   * Voraussetzung ist, dass ein Preload-Skript `window.electron.ipcRenderer.invoke` bereitstellt.\n   */\n  const sendMessage = async (payload: { message: string; history?: any[]; config?: any; }) => {\n    // @ts-ignore - Wir gehen davon aus, dass das Preload-Skript die Funktion bereitstellt\n    return mainWindow.evaluate((p) => window.electron.ipcRenderer.invoke('chat:send-message', p), payload);\n  };\n\n  test.describe('IPC Communication & Provider Switching', () => {\n\n    test('sollte eine erfolgreiche Antwort von OpenAI √ºber IPC erhalten', async () => {\n      // 1. Mock: Simuliere eine erfolgreiche Antwort von der OpenAI API\n      nock(OPENAI_API_HOST)\n        .post('/v1/chat/completions')\n        .reply(200, {\n          id: 'chatcmpl-123',\n          object: 'chat.completion',\n          created: Date.now(),\n          model: 'gpt-4-turbo',\n          choices: [{\n            index: 0,\n            message: { role: 'assistant', content: 'Dies ist eine gemockte OpenAI-Antwort.' },\n            finish_reason: 'stop'\n          }],\n          usage: { prompt_tokens: 10, completion_tokens: 5, total_tokens: 15 }\n        });\n\n      // 2. Aktion: Sende eine Nachricht √ºber IPC\n      const response = await sendMessage({\n        message: 'Hallo Welt',\n        config: { provider: 'openai', apiKey: 'sk-valid-key' }\n      });\n\n      // 3. Pr√ºfung: Validiere die Antwortstruktur\n      expect(response.success).toBe(true);\n      expect(response.reply).toBe('Dies ist eine gemockte OpenAI-Antwort.');\n      expect(response.provider).toBe('openai');\n      expect(response.usage).toEqual({ prompt_tokens: 10, completion_tokens: 5, total_tokens: 15 });\n      expect(response.error).toBeNull();\n    });\n\n    test('sollte den Mock-Provider korrekt verwenden, wenn konfiguriert', async () => {\n      // Aktion: Fordere explizit den Mock-Provider an\n      const response = await sendMessage({ \n        message: 'Nutze den Mock-Provider',\n        config: { provider: 'mock' }\n      });\n\n      // Pr√ºfung: Der Mock-Provider sollte eine vordefinierte Antwort liefern, ohne API-Call.\n      expect(response.success).toBe(true);\n      expect(response.reply).toContain('Dies ist eine Mock-Antwort f√ºr Testzwecke.');\n      expect(response.provider).toBe('mock');\n      expect(response.error).toBeNull();\n    });\n\n    test('sollte einen Fehler zur√ºckgeben, wenn ein unbekannter Provider angefordert wird', async () => {\n      // Aktion: Fordere einen nicht existierenden Provider an\n      const response = await sendMessage({\n        message: 'Test',\n        config: { provider: 'provider-gibt-es-nicht' }\n      });\n\n      // Pr√ºfung: Erwarte eine klare Fehlermeldung.\n      expect(response.success).toBe(false);\n      expect(response.reply).toBeNull();\n      expect(response.error).toContain('Unbekannter Provider: provider-gibt-es-nicht');\n    });\n  });\n\n  test.describe('API Key and Error Handling', () => {\n\n    test('sollte einen Fehler melden, wenn der API-Key f√ºr OpenAI fehlt', async () => {\n      const response = await sendMessage({\n        message: 'Test ohne Key',\n        config: { provider: 'openai' } // Absichtlich ohne apiKey\n      });\n\n      expect(response.success).toBe(false);\n      expect(response.error).toContain('API key is missing for provider: openai');\n    });\n\n    test('sollte einen Fehler melden, wenn der OpenAI API-Key ung√ºltig ist (401)', async () => {\n      // Mock: Simuliere eine 401 Unauthorized-Antwort\n      nock(OPENAI_API_HOST)\n        .post('/v1/chat/completions')\n        .reply(401, { error: { message: 'Incorrect API key provided.' } });\n\n      const response = await sendMessage({\n        message: 'Test mit falschem Key',\n        config: { provider: 'openai', apiKey: 'sk-invalid-key' }\n      });\n\n      expect(response.success).toBe(false);\n      expect(response.error).toMatch(/API request failed.*401.*Invalid API key/i);\n      expect(response.provider).toBe('openai');\n    });\n\n    test('sollte einen API-Fehler (500) korrekt an den Renderer weiterleiten', async () => {\n      // Mock: Simuliere einen Serverfehler\n      nock(OPENAI_API_HOST)\n        .post('/v1/chat/completions')\n        .reply(500, { error: { message: 'The server had an error while processing your request.' } });\n\n      const response = await sendMessage({\n        message: 'L√∂se einen Serverfehler aus',\n        config: { provider: 'openai', apiKey: 'sk-valid-key' }\n      });\n\n      expect(response.success).toBe(false);\n      expect(response.error).toMatch(/API request failed.*500/);\n    });\n\n    test('sollte einen Rate-Limit-Fehler (429) korrekt behandeln', async () => {\n      // Mock: Simuliere einen Rate-Limit-Fehler\n      nock(OPENAI_API_HOST)\n        .post('/v1/chat/completions')\n        .reply(429, { error: { message: 'You exceeded your current quota, please check your plan and billing details.' } });\n\n      const response = await sendMessage({\n        message: 'L√∂se Rate Limit aus',\n        config: { provider: 'openai', apiKey: 'sk-valid-key' }\n      });\n\n      expect(response.success).toBe(false);\n      expect(response.error).toMatch(/Rate limit exceeded.*429/i);\n    });\n  });\n\n  test.describe('Edge Cases', () => {\n\n    test('sollte eine leere Nachricht abweisen', async () => {\n      const response = await sendMessage({ message: '' });\n\n      expect(response.success).toBe(false);\n      expect(response.error).toBe('Message cannot be empty.');\n    });\n\n    test('sollte eine Nachricht mit nur Leerzeichen abweisen', async () => {\n      const response = await sendMessage({ message: '   \\n\\t   ' });\n\n      expect(response.success).toBe(false);\n      expect(response.error).toBe('Message cannot be empty.');\n    });\n\n    test('sollte mit einer sehr langen Nachricht umgehen k√∂nnen (erfolgreicher Call)', async () => {\n      // Mock f√ºr einen erfolgreichen Call\n      nock(OPENAI_API_HOST)\n        .post('/v1/chat/completions')\n        .reply(200, { choices: [{ message: { content: 'Lange Antwort.' } }] });\n      \n      const longMessage = 'A'.repeat(5000);\n      const response = await sendMessage({\n        message: longMessage,\n        config: { provider: 'openai', apiKey: 'sk-valid-key' }\n      });\n\n      expect(response.success).toBe(true);\n      expect(response.reply).toBe('Lange Antwort.');\n    });\n\n  });\n});\n"
  }
]